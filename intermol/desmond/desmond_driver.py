from collections import OrderedDict
import logging
import os
import subprocess

import simtk.unit as units

import intermol.tests
from intermol.tests.testing_tools import which
from intermol.desmond_parser import load_desmond, write_desmond
import shutil

logger = logging.getLogger('InterMolLog')

def read_file(infile):
    tests_path = os.path.dirname(intermol.tests.__file__)
    logger.info('Reading DESMOND file {0}'.format(infile))
    system = load_desmond(infile)
    logger.info('...loaded')
    return system

def write_file(outfile):
    logger.info('Writing DESMOND file {0}'.format(outfile))
    write_desmond(outfile)
    logger.info('...done')

# --------- energy evaluation methods ---------- #

key_dict = {'en': 'Raw Potential',
            'E_p': 'Potential',
            'E_k':'Kinetic En.',
            'E_x';'Extended En.',
            'stretch';'Bond',
            'angle';'Angle',
            'dihedral';'All dihedrals',
            'pair_vdw';'LJ-14',
            'pair_elec';'Coulomb-14',
            }
def standardize_key(in_key):
    if in_key in key_dict:
        out_key = key_dict[in_key]
    else:
        out_key = in_key
    return out_key

def get_desmond_energy_from_file(energy_file):
    ''' 
    parses the desmond energy file
    '''
    with open(energy_file, 'r') as f:
        data = []
        types = []

        # first line of enegrp.dat file contains total energy terms
        line = f.readline() 
        if line.startswith('time=0.000000'): # just to make sure the line is what we think it is
            terms = line.split()
            terms = terms[1:-2] # don't want time, pressure, or volume
            for term in terms:
                key, value = term.split('=')
                types.append(standardize_key(key))
                data.append(float(value))

        # parse rest of file for individual energy grouops
        for line in f:
            if '(0.000000)' in line: # time 0
                words = line.split()
                if words[-1] == 'total':
                    continue
                key = standardize_key(words[0])
                if key:
                    types.append(key)
                    data.append(words[-1])
    data = [float(value) * units.kilocalories_per_mole for value in data]
    e_out = OrderedDict(zip(types, data))
    return e_out

def desmond_energies(cms, cfg, despath):
    """
    Evalutes energies of DESMOND files
    Args:
        cms = cms file
        cfg = cfg file
        despath = path to DESMOND binaries

    """
    logger.info('Evaluating energy of {0}'.format(cms))

    cms = os.path.abspath(cms)
    cfg = os.path.abspath(cfg)
    direc, cms_filename = os.path.split(cms)
    cwd = os.getcwd()
    name = os.path.splitext(cms_filename)[0]
    energy_file = '%s/%s.enegrp.dat' % (direc, name)
    if not despath == '':
        desmond_bin = os.path.join(despath,'desmond')
    else:
        desmond_bin = os.path.join(os.environ.get('SCHRODINGER'),'desmond')

    # use DESMOND To evaluate energy
    #    cd to directory of cms file so that files generated by desmond
    #    don't clog the working directory
    os.chdir(direc)   
    if os.path.exists('trj'):
        shutil.rmtree('trj')
    cmd = [desmond_bin, '-WAIT', '-P', '1', '-in', cms, '-JOBNAME', name, '-c', cfg]
    logger.debug('Running DESMOND with command:\n    %s' % ' '.join(cmd))
    with open('desmond_stdout.txt','w') as out, open('desmond_stderr.txt','w') as err:
        exit = subprocess.call(cmd, stdout=out, stderr=err)
    os.chdir(cwd)

    if exit: # exit status not 0
        logger.error('Energy evaluation failed. See %s/desmond_stderr.txt' % direc)
        raise Exception('Energy evaluation failed for {0}'.format(cms))
    
    # parse desmond energy file
    tot_energy = get_desmond_energy_from_file(energy_file)
    return tot_energy, energy_file

